// Generated by CoffeeScript 1.12.6
(function() {
  var Oscilloscope,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Oscilloscope = (function() {
    function Oscilloscope(source, options) {
      if (options == null) {
        options = {};
      }
      this.draw = bind(this.draw, this);
      this.stop = bind(this.stop, this);
      this.animate = bind(this.animate, this);
      if (!(this instanceof Oscilloscope)) {
        return new Oscilloscope(source, options);
      }
      if (!(source instanceof AudioNode)) {
        throw new Error("Signal must be an AudioNode");
      }
      if (source instanceof AnalyserNode) {
        this.analyser = source;
      } else {
        this.analyser = source.context.createAnalyser();
        source.connect(this.analyser);
      }
      if (options.fftSize) {
        this.analyser.fftSize = options.fftSize;
      }
      this.timeDomain = new Uint8Array(this.analyser.frequencyBinCount);
      this.drawRequest = 0;
    }

    Oscilloscope.prototype.animate = function(ctx1, x0, y0, width, height) {
      var drawLoop;
      this.ctx = ctx1;
      if (this.drawRequest) {
        return;
      }
      return (drawLoop = (function(_this) {
        return function() {
          _this.ctx.clearRect(0, 0, _this.ctx.canvas.width, _this.ctx.canvas.height);
          _this.draw(_this.ctx, x0, y0, width, height);
          return _this.drawRequest = window.requestAnimationFrame(drawLoop);
        };
      })(this))();
    };

    Oscilloscope.prototype.stop = function() {
      cancelAnimationFrame(this.drawRequest);
      this.drawRequest = 0;
      return this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    };

    Oscilloscope.prototype.draw = function(ctx, x0, y0, width, height) {
      var i, j, len, percent, ref, step, value, x, y;
      x0 = x0 || 0;
      y0 = y0 || 0;
      width = width || (ctx.canvas.width - x0);
      height = height || (ctx.canvas.height - y0);
      this.analyser.getByteTimeDomainData(this.timeDomain);
      step = width / this.timeDomain.length;
      ctx.beginPath();
      ref = this.timeDomain;
      for (i = j = 0, len = ref.length; j < len; i = j += 2) {
        value = ref[i];
        percent = value / 256;
        x = x0 + i * step;
        y = y0 + height * percent;
        ctx.lineTo(x, y);
      }
      return ctx.stroke();
    };

    return Oscilloscope;

  })();

  module.exports = Oscilloscope;

}).call(this);
